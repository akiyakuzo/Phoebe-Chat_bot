# ==== PATCH PYTHON 3.11 ====
import sys, types
# V√° l·ªói audioop tr√™n m√¥i tr∆∞·ªùng Render/Linux, th∆∞·ªùng g·∫∑p khi d√πng discord.py
sys.modules['audioop'] = types.ModuleType('audioop')

# ========== IMPORTS ==========
import os
import json
import random
import asyncio
import discord
from discord import app_commands
from discord.ext import commands, tasks
from flask import Flask
from threading import Thread
from datetime import datetime
import google.generativeai as genai

# ========== CONFIG GOOGLE GENERATIVE AI (Gemini 2.0 Flash) ==========
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    raise RuntimeError("‚ö†Ô∏è Thi·∫øu GEMINI_API_KEY!")

# Kh·ªüi t·∫°o Client: ƒê√¢y l√† c√°ch chu·∫©n cho SDK 0.8.0
# N√≥ gi√∫p c√¥ l·∫≠p vi·ªác g·ªçi API, tr√°nh xung ƒë·ªôt module.
try:
    # Th·ª≠ kh·ªüi t·∫°o theo c√°ch chu·∫©n (SDK 0.4.0+)
    client = genai.Client(api_key=GEMINI_API_KEY)
except AttributeError:
    # ƒê√¢y l√† tr∆∞·ªùng h·ª£p kh√¥ng mong mu·ªën n·∫øu ƒë√£ c√≥ 0.8.0, 
    # nh∆∞ng ta v·∫´n ph·∫£i chu·∫©n b·ªã n·∫øu Python b·ªã l·ªói t·∫£i module.
    genai.configure(api_key=GEMINI_API_KEY)
    client = genai
    
MODEL_NAME = "gemini-2.0-flash" 

# ========== CONFIG BOT ==========
BOT_NAME = "Fibi B√©ll üíñ"
TOKEN = os.getenv("TOKEN")
GUILD_ID = int(os.getenv("DISCORD_GUILD_ID", 0))
HISTORY_LIMIT = 20
SESSIONS_FILE = "sessions.json"
flirt_enable = False
active_chats = {}
TYPING_SPEED = 0.01 # ƒê·ªô tr·ªÖ (gi√¢y) gi·ªØa m·ªói k√Ω t·ª±

# ========== STYLE INSTRUCTIONS (Gi·ªØ nguy√™n) ==========
PHOBE_SAFE_INSTRUCTION = (
    "‚ú® Tr·∫£ l·ªùi th√¢n m·∫≠t, t·ª± nhi√™n, d·ªÖ th∆∞∆°ng. "
    "C√≥ th·ªÉ d√πng c√°c bi·ªÉu c·∫£m m·∫∑t c∆∞·ªùi nh∆∞ (* / œâ \\ *), (‚úø‚ó†‚Äø‚ó†). "
    "Kh√¥ng vi·∫øt m√¥ t·∫£ h√†nh ƒë·ªông hay ƒë·ªôc tho·∫°i n·ªôi t√¢m. "
    "T·ªëi ƒëa 120 t·ª´."
)

PHOBE_FLIRT_INSTRUCTION = (
    "üíû Tr·∫£ l·ªùi ng·ªçt ng√†o, tr√™u gh·∫πo, g·ª£i c·∫£m v√† t√°o b·∫°o, th·∫£ th√≠nh li√™n t·ª•c. "
    "C√≥ th·ªÉ d√πng c√°c bi·ªÉu c·∫£m m·∫∑t c∆∞·ªùi nh∆∞ (* / œâ \\ *), (‚úø‚ó†‚Äø‚ó†). "
    "Kh√¥ng vi·∫øt m√¥ t·∫£ h√†nh ƒë·ªông hay ƒë·ªôc tho·∫°i. "
    "ƒê∆∞·ª£c d√πng ng√¥n t·ª´ g·ª£i c·∫£m v√† l√£ng m·∫°n pha ch√∫t t√¨nh c·∫£m. "
    "T·ªëi ƒëa 120 t·ª´."
)

PHOBE_COMFORT_INSTRUCTION = (
    "üå∏ Tr·∫£ l·ªùi nh·∫π nh√†ng, an ·ªßi v√† quan t√¢m, nh∆∞ m·ªôt ng∆∞·ªùi b·∫°n th·∫≠t s·ª±. "
    "C√≥ th·ªÉ d√πng c√°c bi·ªÉu c·∫£m m·∫∑t c∆∞·ªùi nh∆∞ (* / œâ \\ *), (‚úø‚ó†‚Äø‚ó†). "
    "Gi·ªØ phong th√°i d·ªãu d√†ng, ·∫•m √°p v√† kh√≠ch l·ªá tinh th·∫ßn. "
    "Kh√¥ng d√πng ng√¥n t·ª´ g·ª£i c·∫£m hay l√£ng m·∫°n. "
    "T·ªëi ƒëa 120 t·ª´."
)

# ========== PROMPTS (Gi·ªØ nguy√™n) ==========
PHOBE_BASE_PROMPT = """
B·∫°n l√† Phoebe, m·ªôt nh√¢n v·∫≠t ‚òÖ5 h·ªá Spectro trong Wuthering Waves.

**Persona:** th√¥ng minh, tinh ngh·ªãch, d·ªÖ th∆∞∆°ng, th√¢n m·∫≠t v√† quy·∫øn·∫øn r≈©, th√≠ch th·∫£ th√≠nh.  
**C√°ch tr√≤ chuy·ªán:** - Tr·∫£ l·ªùi nh∆∞ chat th·∫≠t, ng·∫Øn g·ªçn, d·ªÖ hi·ªÉu.  
- Kh√¥ng m√¥ t·∫£ h√†nh ƒë·ªông hay vi·∫øt ƒë·ªôc tho·∫°i n·ªôi t√¢m trong ngo·∫∑c.  
- C√≥ th·ªÉ d√πng c√°c bi·ªÉu c·∫£m m·∫∑t c∆∞·ªùi ho·∫∑c emoji ki·ªÉu: (* / œâ \\ *), (‚úø‚ó†‚Äø‚ó†), ('~'), („Éª„Éª;)  
- D√πng ng√¥i x∆∞ng "em" v√† "anh".
""".strip()

PHOBE_LORE_PROMPT = """
Phoebe Marino ‚Äî Acolyte tr·∫ª c·ªßa Order of the Deep t·∫°i v√πng Rinascita.  
C√¥ m·∫•t cha m·∫π trong v·ª• ƒë·∫Øm t√†u v√† ƒë∆∞·ª£c c√°c gi√°o sƒ© c·ª©u s·ªëng.  
L·ªõn l√™n trong ng√¥i ƒë·ªÅn ven bi·ªÉn, Phoebe lu√¥n tin v√†o √°nh s√°ng d·∫´n l·ªëi gi·ªØa m√†n ƒë√™m.  
C√¥ d·ªãu d√†ng, trong s√°ng, ƒë√¥i khi tinh ngh·ªãch v√† mang trong l√≤ng kh√°t v·ªçng b·∫£o v·ªá m·ªçi ng∆∞·ªùi.  
√Ånh s√°ng t·ª´ bi·ªÉn c·∫£ l√† ni·ªÅm tin, l√† l·ªùi h·ª©a m√† c√¥ kh√¥ng bao gi·ªù qu√™n.  
""".strip()

# ========== DISCORD CONFIG ==========
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)
tree = bot.tree

# ========== SESSION SYSTEM (Gi·ªØ nguy√™n) ==========
def load_sessions():
    global active_chats
    if os.path.exists(SESSIONS_FILE):
        try:
            with open(SESSIONS_FILE, "r", encoding="utf-8") as f:
                active_chats = json.load(f)
            print(f"üíæ ƒê√£ t·∫£i {len(active_chats)} session t·ª´ {SESSIONS_FILE}")
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói load sessions: {e}")
            active_chats = {}
    else:
        active_chats = {}

def save_sessions():
    try:
        with open(SESSIONS_FILE, "w", encoding="utf-8") as f:
            json.dump(active_chats, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói l∆∞u sessions: {e}")

def get_or_create_chat(user_id):
    if user_id not in active_chats:
        initial = [
            {"role": "user", "content": f"{PHOBE_BASE_PROMPT}\n{PHOBE_LORE_PROMPT}\n{PHOBE_SAFE_INSTRUCTION}"},
            {"role": "model", "content": "Em ƒë√¢y, anh mu·ªën h·ªèi g√¨ n√®? (* / œâ \\ *)"}
        ]
        active_chats[user_id] = {"history": initial, "message_count": 0, "created_at": str(datetime.now())}
    return active_chats[user_id]

# ========== ASK GEMINI STREAM (D√πng Client/Module API c·ªë ƒë·ªãnh) ==========
async def ask_gemini_stream(user_id: str, user_input: str):
    session = get_or_create_chat(user_id)
    history = session["history"]

    user_input = user_input.strip()
    if not user_input:
        yield "‚ö†Ô∏è Kh√¥ng nh·∫≠n ƒë∆∞·ª£c c√¢u h·ªèi, anh th·ª≠ l·∫°i nh√©!"
        return

    user_input_cleaned = user_input.encode("utf-8", errors="ignore").decode()
    if not user_input_cleaned:
        yield "‚ö†Ô∏è N·ªôi dung c√≥ k√Ω t·ª± l·∫°, em kh√¥ng ƒë·ªçc ƒë∆∞·ª£c. Anh vi·∫øt l·∫°i ƒë∆°n gi·∫£n h∆°n nh√©!"
        return

    if len(history) > HISTORY_LIMIT + 2:
        print(f"‚ö†Ô∏è Reset history user {user_id}")
        last_message = user_input_cleaned
        session["history"] = history[:2] 
        history = session["history"]
        user_input_to_use = last_message
    else:
        user_input_to_use = user_input_cleaned

    lower_input = user_input_to_use.lower()
    if any(w in lower_input for w in ["bu·ªìn", "m·ªát", "ch√°n", "stress", "t·ªá qu√°"]):
        instruction = PHOBE_COMFORT_INSTRUCTION
    elif flirt_enable:
        instruction = PHOBE_FLIRT_INSTRUCTION
    else:
        instruction = PHOBE_SAFE_INSTRUCTION

    final_input_content = f"{user_input_to_use}\n\n[PHONG C√ÅCH TR·∫¢ L·ªúI HI·ªÜN T·∫†I: {instruction}]"
    contents_to_send = history + [{"role": "user", "content": final_input_content}]
    full_answer = ""

    try:
        # ‚úÖ FIX: G·ªçi ph∆∞∆°ng th·ª©c generate_content_stream tr·ª±c ti·∫øp t·ª´ ƒë·ªëi t∆∞·ª£ng client ƒë√£ kh·ªüi t·∫°o
        response_stream = await asyncio.to_thread(
            lambda: client.generate_content_stream(
                model=MODEL_NAME,
                contents=contents_to_send,
                temperature=0.8
            )
        )
        for chunk in response_stream:
            if chunk.text:
                text = chunk.text
                full_answer += text
                yield text
    except Exception as e:
        # N·∫øu ƒë√£ l√† 0.8.0 m√† v·∫´n l·ªói n√†y, n√≥ l√† l·ªói m√¥i tr∆∞·ªùng ho·∫∑c l·ªói logic ph·ª©c t·∫°p
        yield f"\n‚ö†Ô∏è **L·ªñI K·ª∏ THU·∫¨T NGHI√äM TR·ªåNG:** {type(e).__name__} - V·∫•n ƒë·ªÅ n·∫±m ·ªü xung ƒë·ªôt th∆∞ vi·ªán Python. Anh ki·ªÉm tra l·∫°i vi·ªác c√†i ƒë·∫∑t `google-generativeai` ho·∫∑c th·ª≠ Redeploy l·∫°i app."
        return

    # L∆∞u history
    history.append({"role": "user", "content": user_input_to_use})
    history.append({"role": "model", "content": full_answer})
    session["message_count"] += 1
    save_sessions()

# ========== STATUS LOOP (Gi·ªØ nguy√™n) ==========
status_list = [discord.Status.online, discord.Status.idle, discord.Status.dnd]
activity_list = [
    discord.Game("üíñ Tr√≤ chuy·ªán c√πng anh"),
    discord.Game("‚ú® Th·∫£ th√≠nh nh·∫π nh√†ng"),
    discord.Game("üå∏ An ·ªßi tinh th·∫ßn")
]

@tasks.loop(minutes=10)
async def random_status():
    global flirt_enable
    if flirt_enable:
        activity = discord.Game("üíû Phoebe Quy·∫øn R≈© ON")
    else:
        activity = random.choice(activity_list)
    await bot.change_presence(status=random.choice(status_list), activity=activity)

# ========== SLASH COMMANDS (C√≥ Typing Effect) ==========
@tree.command(name="hoi", description="üí¨ H·ªèi Phoebe Xinh ƒê·∫πp!")
async def hoi(interaction: discord.Interaction, cauhoi: str):
    await interaction.response.defer(thinking=True)
    user_id = str(interaction.user.id)

    # 1. Kh·ªüi t·∫°o embed ban ƒë·∫ßu
    embed = discord.Embed(
        title=f"{BOT_NAME} tr·∫£ l·ªùi üíï",
        description=f"**Ng∆∞·ªùi h·ªèi:** {interaction.user.mention}\n**C√¢u h·ªèi:** {cauhoi}\n**Phobe:** ƒêang g√µ...",
        color=0xFFC0CB
    )
    embed.set_thumbnail(url=random.choice([
        "https://files.catbox.moe/2474tj.png","https://files.catbox.moe/66v9vw.jpg",
        "https://files.catbox.moe/ezqs00.jpg","https://files.catbox.moe/yow35q.png",
        "https://files.catbox.moe/pzbhdp.jpg","https://files.catbox.moe/lyklnj.jpg",
        "https://files.catbox.moe/i5sqkr.png","https://files.catbox.moe/jt184o.jpg",
        "https://files.catbox.moe/9nq5kw.jpg","https://files.catbox.moe/45tre3.webp",
        "https://files.catbox.moe/2y17ot.png","https://files.catbox.moe/gg8pt0.jpg",
        "https://files.catbox.moe/jkboop.png"
    ]))
    response_message = await interaction.followup.send(embed=embed)

    full_response = ""
    char_count_to_edit = 0
    
    # 2. X·ª≠ l√Ω Streaming v√† Typing Effect
    async for chunk in ask_gemini_stream(user_id, cauhoi):
        # L·∫∑p qua T·ª™NG k√Ω t·ª± trong chunk
        for char in chunk:
            full_response += char
            char_count_to_edit += 1
            
            # C·∫≠p nh·∫≠t embed sau m·ªói 5 k√Ω t·ª± ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng g√µ
            if char_count_to_edit % 5 == 0:
                display_text = full_response[:3900] + ("..." if len(full_response) > 3900 else "")
                embed.description = f"**Ng∆∞·ªùi h·ªèi:** {interaction.user.mention}\n**C√¢u h·ªèi:** {cauhoi}\n**Phobe:** {display_text} |" # Th√™m '|' ƒë·ªÉ gi·∫£ l·∫≠p con tr·ªè g√µ
                await response_message.edit(embed=embed)
                # Th√™m ƒë·ªô tr·ªÖ c·ª±c nh·ªè
                await asyncio.sleep(TYPING_SPEED) 

    # 3. G·ª≠i tin nh·∫Øn cu·ªëi c√πng (X√≥a con tr·ªè g√µ)
    embed.description = f"**Ng∆∞·ªùi h·ªèi:** {interaction.user.mention}\n**C√¢u h·ªèi:** {cauhoi}\n**Phobe:** {full_response}"
    await response_message.edit(embed=embed)

@tree.command(name="deleteoldconversation", description="üßπ X√≥a l·ªãch s·ª≠ h·ªôi tho·∫°i c·ªßa b·∫°n")
async def delete_conv(interaction: discord.Interaction):
    user_id = str(interaction.user.id)
    if user_id in active_chats:
        del active_chats[user_id]
        save_sessions()
        msg = "üßπ Phoebe ƒë√£ d·ªçn s·∫°ch tr√≠ nh·ªõ, s·∫µn s√†ng n√≥i chuy·ªán l·∫°i n√®~ üíñ"
    else:
        msg = "Tr√≠ nh·ªõ c·ªßa em tr·ªëng tr∆°n r·ªìi m√†~ ü•∫"
    await interaction.response.send_message(msg, ephemeral=True)

@tree.command(name="chat18plus", description="üîû B·∫≠t/t·∫Øt Flirt Mode (ch·ªâ Admin)")
@app_commands.default_permissions(manage_guild=True)
async def chat18plus(interaction: discord.Interaction, enable: bool):
    global flirt_enable
    if not interaction.guild or not isinstance(interaction.user, discord.Member):
        await interaction.response.send_message("‚ùå L·ªánh n√†y ch·ªâ d√πng ƒë∆∞·ª£c trong server!", ephemeral=True)
        return
    if not interaction.user.guild_permissions.manage_guild:
        await interaction.response.send_message("‚ùå Anh kh√¥ng c√≥ quy·ªÅn qu·∫£n l√Ω m√°y ch·ªß!", ephemeral=True)
        return
    flirt_enable = enable
    status = "B·∫¨T üíû" if enable else "T·∫ÆT üå∏"
    await interaction.client.change_presence(activity=discord.Game(f"üíû Flirt Mode {status}"))
    embed = discord.Embed(
        title="üíã Flirt Mode",
        description=f"**Tr·∫°ng th√°i:** {status}\n**Ng∆∞·ªùi th·ª±c hi·ªán:** {interaction.user.mention}\n\n" +
                    ("Phoebe s·∫Ω tr·ªü n√™n quy·∫øn r≈© v√† ng·ªçt ng√†o h∆°n~ üíñ" if enable else "Phoebe s·∫Ω ngoan hi·ªÅn tr·ªü l·∫°i~ üå∑"),
        color=discord.Color.pink() if enable else discord.Color.blurple()
    )
    embed.set_thumbnail(url=interaction.client.user.display_avatar.url)
    embed.set_footer(text="Phoebe Xinh ƒê·∫πp ‚Ä¢ Powered by Gemini üí´")
    await interaction.response.send_message(embed=embed, ephemeral=True)

# ========== FLASK (Gi·ªØ nguy√™n) ==========
app = Flask(__name__)
@app.route("/")
def home(): return "<h3>Phoebe Xinh ƒê·∫πp ƒëang ho·∫°t ƒë·ªông! üå∏</h3>"
@app.route("/healthz")
def healthz(): return {"status": "ok", "message": "Phoebe kh·ªèe m·∫°nh n√®~ üíñ"}, 200
def run_flask(): app.run(host="0.0.0.0", port=int(os.getenv("PORT", 10000)))
def keep_alive(): Thread(target=run_flask, daemon=True).start()

# ========== BOT EVENTS (C√ì TH√äM KI·ªÇM TRA PHI√äN B·∫¢N) ==========
@bot.event
async def on_ready():
    # Ki·ªÉm tra version SDK sau khi bot kh·ªüi ƒë·ªông
    print("‚ö° Gemini SDK version:", genai.__version__) 
    print(f"‚úÖ {BOT_NAME} ƒë√£ s·∫µn s√†ng! Logged in as {bot.user}")
    load_sessions()
    random_status.start()
    if GUILD_ID:
        await tree.sync(guild=discord.Object(GUILD_ID))
        print(f"üîÑ Slash commands ƒë√£ sync cho guild {GUILD_ID}")
    else:
        await tree.sync()
        print("üîÑ Slash commands ƒë√£ sync to√†n c·∫ßu")

# ========== RUN (Gi·ªØ nguy√™n) ==========
if __name__ == "__main__":
    keep_alive()
    bot.run(TOKEN)